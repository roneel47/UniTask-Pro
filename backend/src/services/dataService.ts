import User from '@/models/User';
import Task from '@/models/Task';
import TaskAssignmentMeta from '@/models/TaskAssignmentMeta';
import type { User as UserType, Task as TaskType, TaskAssignmentMeta as TaskAssignmentMetaType } from '@/types';
import type { IUserDocument } from '@/models/User';
import type { ITaskDocument } from '@/models/Task';
import type { ITaskAssignmentMetaDocument } from '@/models/TaskAssignmentMeta';

// User functions
export const getUsers = async (): Promise<UserType[]> => {
  return await User.find().lean(); // .lean() returns plain JS objects
};

export const findUserByUsn = async (usn: string): Promise<UserType | null> => {
  return await User.findOne({ usn: usn.toUpperCase() }).lean();
};

export const findUserById = async (id: string): Promise<UserType | null> => {
  // In current setup 'id' is USN. If it was MongoDB _id, it would be User.findById(id)
  return await User.findOne({ id: id.toUpperCase() }).lean();
};

export const addUser = async (userData: Omit<UserType, 'id'> & {id: string}): Promise<UserType> => {
    // Ensure USN is uppercase and id is set correctly.
    const userToCreate = {
        ...userData,
        usn: userData.usn.toUpperCase(),
        id: userData.id.toUpperCase(), // Assuming id is passed and is the USN
    };
    const newUser = new User(userToCreate);
    await newUser.save();
    return newUser.toObject() as UserType; // toObject() converts Mongoose doc to plain object
};


export const updateUser = async (id: string, updates: Partial<UserType>): Promise<UserType | null> => {
  // If 'id' is USN. If it were MongoDB _id, findByIdAndUpdate would be used.
  const updatedUser = await User.findOneAndUpdate({ id: id.toUpperCase() }, updates, { new: true }).lean();
  return updatedUser;
};

export const deleteUser = async (id: string): Promise<boolean> => {
  const userToDelete = await User.findOne({ id: id.toUpperCase() });
  if (!userToDelete) return false;

  const usn = userToDelete.usn;

  // Delete tasks assigned TO this user
  await Task.deleteMany({ assignedToUsn: usn });

  // If user was an admin, delete TaskAssignmentMeta created BY this user and their associated tasks
  if (userToDelete.role === 'admin' || userToDelete.role === 'master-admin') {
    const metasByAdmin = await TaskAssignmentMeta.find({ assigningAdminUsn: usn });
    for (const meta of metasByAdmin) {
      await Task.deleteMany({ taskAssignmentMetaId: meta._id });
    }
    await TaskAssignmentMeta.deleteMany({ assigningAdminUsn: usn });
  }
  
  await User.deleteOne({ id: id.toUpperCase() });
  return true;
};


// Task functions
export const getTasks = async (): Promise<TaskType[]> => {
  return await Task.find().lean();
};

export const getTasksByAssignedUsn = async (usn: string): Promise<TaskType[]> => {
  return await Task.find({ assignedToUsn: usn.toUpperCase() }).sort({ dueDate: 1 }).lean();
};

export const findTaskById = async (taskId: string): Promise<TaskType | null> => {
  return await Task.findById(taskId).lean();
};

export const addTasks = async (newTasksData: TaskType[]): Promise<TaskType[]> => {
  // Mongoose's insertMany returns an array of the inserted documents.
  // We need to map them to plain objects if not using .lean() by default.
  const createdTasksDocs = await Task.insertMany(newTasksData);
  return createdTasksDocs.map(doc => doc.toObject() as TaskType);
};


export const updateTask = async (taskId: string, updates: Partial<TaskType>): Promise<TaskType | null> => {
  const taskUpdates = { ...updates, updatedAt: new Date() };
  return await Task.findByIdAndUpdate(taskId, taskUpdates, { new: true }).lean();
};

export const deleteTask = async (taskId: string): Promise<boolean> => {
  const result = await Task.findByIdAndDelete(taskId);
  return !!result;
};

export const getTasksByMetaId = async (metaId: string): Promise<TaskType[]> => {
  return await Task.find({ taskAssignmentMetaId: metaId }).lean();
};


// TaskAssignmentMeta functions
export const getTaskAssignmentsMeta = async (): Promise<TaskAssignmentMetaType[]> => {
  return await TaskAssignmentMeta.find().lean();
};

export const getTaskAssignmentsMetaByAdmin = async (adminUsn: string): Promise<TaskAssignmentMetaType[]> => {
    return await TaskAssignmentMeta.find({ assigningAdminUsn: adminUsn.toUpperCase() }).sort({ createdAt: -1 }).lean();
};

export const findTaskAssignmentMetaById = async (metaId: string): Promise<TaskAssignmentMetaType | null> => {
  return await TaskAssignmentMeta.findById(metaId).lean();
};

export const addTaskAssignmentMeta = async (metaData: Omit<TaskAssignmentMetaType, 'id' | 'createdAt' | 'updatedAt'>): Promise<TaskAssignmentMetaType> => {
  // _id will be generated by MongoDB, id field from type is not used here as primary key
  const newMeta = new TaskAssignmentMeta(metaData);
  await newMeta.save();
  return newMeta.toObject() as TaskAssignmentMetaType;
};

export const deleteTaskAssignmentMeta = async (metaId: string): Promise<boolean> => {
  const meta = await TaskAssignmentMeta.findById(metaId);
  if (!meta) return false;

  // Delete associated tasks
  await Task.deleteMany({ taskAssignmentMetaId: meta._id });
  
  await TaskAssignmentMeta.findByIdAndDelete(metaId);
  return true;
};

// No need for initializeDataFiles with MongoDB
